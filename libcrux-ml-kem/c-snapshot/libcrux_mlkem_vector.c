/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /nix/store/c9m211bm84ncjmaxx27ki9dymd4qkwm2-ocaml4.14.1-eurydice-dirty/eurydice --config ../c.yaml ../../libcrux_ml_kem.llbc
  F* version: <unknown>
  KaRaMeL version: <unknown>
 */

#include "internal/libcrux_mlkem_vector.h"

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_zero(void)
{
  libcrux_ml_kem_vector_PortableVector lit;
  lit.elements[0U] = (int16_t)0;
  lit.elements[1U] = (int16_t)0;
  lit.elements[2U] = (int16_t)0;
  lit.elements[3U] = (int16_t)0;
  lit.elements[4U] = (int16_t)0;
  lit.elements[5U] = (int16_t)0;
  lit.elements[6U] = (int16_t)0;
  lit.elements[7U] = (int16_t)0;
  lit.elements[8U] = (int16_t)0;
  lit.elements[9U] = (int16_t)0;
  lit.elements[10U] = (int16_t)0;
  lit.elements[11U] = (int16_t)0;
  lit.elements[12U] = (int16_t)0;
  lit.elements[13U] = (int16_t)0;
  lit.elements[14U] = (int16_t)0;
  lit.elements[15U] = (int16_t)0;
  return lit;
}

typedef struct Result__int16_t_16size_t__core_array_TryFromSliceError_s
{
  core_result_Result__int16_t_16size_t__core_array_TryFromSliceError_tags tag;
  union {
    int16_t case_Ok[16U];
    core_array_TryFromSliceError case_Err;
  }
  val;
}
Result__int16_t_16size_t__core_array_TryFromSliceError;

static void
unwrap__int16_t_16size_t__core_array_TryFromSliceError(
  Result__int16_t_16size_t__core_array_TryFromSliceError self,
  int16_t ret[16U]
)
{
  if (self.tag == core_result_Ok)
  {
    int16_t f0[16U];
    memcpy(f0, self.val.case_Ok, (size_t)16U * sizeof (int16_t));
    memcpy(ret, f0, (size_t)16U * sizeof (int16_t));
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "unwrap not Ok");
    KRML_HOST_EXIT(255U);
  }
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_from_i16_array(Eurydice_slice array)
{
  libcrux_ml_kem_vector_PortableVector lit;
  int16_t ret[16U];
  Result__int16_t_16size_t__core_array_TryFromSliceError dst;
  Eurydice_slice_to_array2(&dst,
    Eurydice_slice_subslice(array,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)16U }),
      int16_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    Eurydice_slice,
    int16_t [16U],
    void *);
  unwrap__int16_t_16size_t__core_array_TryFromSliceError(dst, ret);
  memcpy(lit.elements, ret, (size_t)16U * sizeof (int16_t));
  return lit;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_add(
  libcrux_ml_kem_vector_PortableVector lhs,
  libcrux_ml_kem_vector_PortableVector *rhs
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    lhs.elements[uu____0] = lhs.elements[uu____0] + rhs->elements[i0];
  }
  return lhs;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_sub(
  libcrux_ml_kem_vector_PortableVector lhs,
  libcrux_ml_kem_vector_PortableVector *rhs
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    lhs.elements[uu____0] = lhs.elements[uu____0] - rhs->elements[i0];
  }
  return lhs;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_multiply_by_constant(libcrux_ml_kem_vector_PortableVector v, int16_t c)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    v.elements[uu____0] = v.elements[uu____0] * c;
  }
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_bitwise_and_with_constant(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t c
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    v.elements[uu____0] = v.elements[uu____0] & c;
  }
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_cond_subtract_3329(libcrux_ml_kem_vector_PortableVector v)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    if (v.elements[i0] >= (int16_t)3329)
    {
      size_t uu____0 = i0;
      v.elements[uu____0] = v.elements[uu____0] - (int16_t)3329;
    }
  }
  return v;
}

int16_t libcrux_ml_kem_vector_barrett_reduce_element(int16_t value)
{
  int32_t
  t =
    (int32_t)value
    * LIBCRUX_ML_KEM_VECTOR_BARRETT_MULTIPLIER
    + (LIBCRUX_ML_KEM_VECTOR_BARRETT_R >> 1U);
  int16_t quotient = (int16_t)(t >> (uint32_t)LIBCRUX_ML_KEM_VECTOR_BARRETT_SHIFT);
  return value - quotient * LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_MODULUS;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_barrett_reduce(libcrux_ml_kem_vector_PortableVector v)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    int16_t uu____0 = libcrux_ml_kem_vector_barrett_reduce_element(v.elements[i0]);
    v.elements[i0] = uu____0;
  }
  return v;
}

int16_t libcrux_ml_kem_vector_montgomery_reduce_element(int32_t value)
{
  int32_t
  k =
    (int32_t)(int16_t)value
    * (int32_t)LIBCRUX_ML_KEM_VECTOR_TRAITS_INVERSE_OF_MODULUS_MOD_MONTGOMERY_R;
  int32_t
  k_times_modulus = (int32_t)(int16_t)k * (int32_t)LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_MODULUS;
  int16_t c = (int16_t)(k_times_modulus >> (uint32_t)LIBCRUX_ML_KEM_VECTOR_MONTGOMERY_SHIFT);
  int16_t value_high = (int16_t)(value >> (uint32_t)LIBCRUX_ML_KEM_VECTOR_MONTGOMERY_SHIFT);
  return value_high - c;
}

inline int16_t libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(int16_t fe, int16_t fer)
{
  return libcrux_ml_kem_vector_montgomery_reduce_element((int32_t)fe * (int32_t)fer);
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_montgomery_multiply_by_constant(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t c
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    int16_t uu____0 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[i0], c);
    v.elements[i0] = uu____0;
  }
  return v;
}

uint8_t libcrux_ml_kem_vector_compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t mask = shifted >> 15U;
  int16_t shifted_to_positive = mask ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  return (uint8_t)(shifted_positive_in_range >> 15U & (int16_t)1);
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_compress_1(libcrux_ml_kem_vector_PortableVector v)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    uint8_t uu____0 = libcrux_ml_kem_vector_compress_message_coefficient((uint16_t)v.elements[i0]);
    v.elements[i0] = (int16_t)uu____0;
  }
  return v;
}

inline uint32_t libcrux_ml_kem_vector_get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

int16_t
libcrux_ml_kem_vector_compress_ciphertext_coefficient(uint8_t coefficient_bits, uint16_t fe)
{
  uint64_t compressed = (uint64_t)fe << (uint32_t)coefficient_bits;
  compressed = compressed + 1664ULL;
  compressed = compressed * 10321340ULL;
  compressed = compressed >> 35U;
  return
    (int16_t)libcrux_ml_kem_vector_get_n_least_significant_bits(coefficient_bits,
      (uint32_t)compressed);
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_ntt_layer_1_step(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3
)
{
  int16_t t = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[2U], zeta0);
  v.elements[2U] = v.elements[0U] - t;
  v.elements[0U] = v.elements[0U] + t;
  int16_t t0 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[3U], zeta0);
  v.elements[3U] = v.elements[1U] - t0;
  v.elements[1U] = v.elements[1U] + t0;
  int16_t t1 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[6U], zeta1);
  v.elements[6U] = v.elements[4U] - t1;
  v.elements[4U] = v.elements[4U] + t1;
  int16_t t2 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[7U], zeta1);
  v.elements[7U] = v.elements[5U] - t2;
  v.elements[5U] = v.elements[5U] + t2;
  int16_t
  t3 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)2U],
      zeta2);
  v.elements[(size_t)8U + (size_t)2U] = v.elements[(size_t)8U + (size_t)0U] - t3;
  v.elements[(size_t)8U + (size_t)0U] = v.elements[(size_t)8U + (size_t)0U] + t3;
  int16_t
  t4 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)3U],
      zeta2);
  v.elements[(size_t)8U + (size_t)3U] = v.elements[(size_t)8U + (size_t)1U] - t4;
  v.elements[(size_t)8U + (size_t)1U] = v.elements[(size_t)8U + (size_t)1U] + t4;
  int16_t
  t5 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)6U],
      zeta3);
  v.elements[(size_t)8U + (size_t)6U] = v.elements[(size_t)8U + (size_t)4U] - t5;
  v.elements[(size_t)8U + (size_t)4U] = v.elements[(size_t)8U + (size_t)4U] + t5;
  int16_t
  t6 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)7U],
      zeta3);
  v.elements[(size_t)8U + (size_t)7U] = v.elements[(size_t)8U + (size_t)5U] - t6;
  v.elements[(size_t)8U + (size_t)5U] = v.elements[(size_t)8U + (size_t)5U] + t6;
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_ntt_layer_2_step(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t zeta0,
  int16_t zeta1
)
{
  int16_t t = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[4U], zeta0);
  v.elements[4U] = v.elements[0U] - t;
  v.elements[0U] = v.elements[0U] + t;
  int16_t t0 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[5U], zeta0);
  v.elements[5U] = v.elements[1U] - t0;
  v.elements[1U] = v.elements[1U] + t0;
  int16_t t1 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[6U], zeta0);
  v.elements[6U] = v.elements[2U] - t1;
  v.elements[2U] = v.elements[2U] + t1;
  int16_t t2 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[7U], zeta0);
  v.elements[7U] = v.elements[3U] - t2;
  v.elements[3U] = v.elements[3U] + t2;
  int16_t
  t3 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)4U],
      zeta1);
  v.elements[(size_t)8U + (size_t)4U] = v.elements[(size_t)8U + (size_t)0U] - t3;
  v.elements[(size_t)8U + (size_t)0U] = v.elements[(size_t)8U + (size_t)0U] + t3;
  int16_t
  t4 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)5U],
      zeta1);
  v.elements[(size_t)8U + (size_t)5U] = v.elements[(size_t)8U + (size_t)1U] - t4;
  v.elements[(size_t)8U + (size_t)1U] = v.elements[(size_t)8U + (size_t)1U] + t4;
  int16_t
  t5 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)6U],
      zeta1);
  v.elements[(size_t)8U + (size_t)6U] = v.elements[(size_t)8U + (size_t)2U] - t5;
  v.elements[(size_t)8U + (size_t)2U] = v.elements[(size_t)8U + (size_t)2U] + t5;
  int16_t
  t6 =
    libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[(size_t)8U + (size_t)7U],
      zeta1);
  v.elements[(size_t)8U + (size_t)7U] = v.elements[(size_t)8U + (size_t)3U] - t6;
  v.elements[(size_t)8U + (size_t)3U] = v.elements[(size_t)8U + (size_t)3U] + t6;
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_ntt_layer_3_step(libcrux_ml_kem_vector_PortableVector v, int16_t zeta)
{
  int16_t t = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[8U], zeta);
  v.elements[8U] = v.elements[0U] - t;
  v.elements[0U] = v.elements[0U] + t;
  int16_t t0 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[9U], zeta);
  v.elements[9U] = v.elements[1U] - t0;
  v.elements[1U] = v.elements[1U] + t0;
  int16_t t1 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[10U], zeta);
  v.elements[10U] = v.elements[2U] - t1;
  v.elements[2U] = v.elements[2U] + t1;
  int16_t t2 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[11U], zeta);
  v.elements[11U] = v.elements[3U] - t2;
  v.elements[3U] = v.elements[3U] + t2;
  int16_t t3 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[12U], zeta);
  v.elements[12U] = v.elements[4U] - t3;
  v.elements[4U] = v.elements[4U] + t3;
  int16_t t4 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[13U], zeta);
  v.elements[13U] = v.elements[5U] - t4;
  v.elements[5U] = v.elements[5U] + t4;
  int16_t t5 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[14U], zeta);
  v.elements[14U] = v.elements[6U] - t5;
  v.elements[6U] = v.elements[6U] + t5;
  int16_t t6 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(v.elements[15U], zeta);
  v.elements[15U] = v.elements[7U] - t6;
  v.elements[7U] = v.elements[7U] + t6;
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_inv_ntt_layer_1_step(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3
)
{
  int16_t a_minus_b = v.elements[2U] - v.elements[0U];
  int16_t
  uu____0 = libcrux_ml_kem_vector_barrett_reduce_element(v.elements[0U] + v.elements[2U]);
  v.elements[0U] = uu____0;
  int16_t uu____1 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b, zeta0);
  v.elements[2U] = uu____1;
  int16_t a_minus_b0 = v.elements[3U] - v.elements[1U];
  int16_t
  uu____2 = libcrux_ml_kem_vector_barrett_reduce_element(v.elements[1U] + v.elements[3U]);
  v.elements[1U] = uu____2;
  int16_t uu____3 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b0, zeta0);
  v.elements[3U] = uu____3;
  int16_t a_minus_b1 = v.elements[6U] - v.elements[4U];
  int16_t
  uu____4 = libcrux_ml_kem_vector_barrett_reduce_element(v.elements[4U] + v.elements[6U]);
  v.elements[4U] = uu____4;
  int16_t uu____5 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b1, zeta1);
  v.elements[6U] = uu____5;
  int16_t a_minus_b2 = v.elements[7U] - v.elements[5U];
  int16_t
  uu____6 = libcrux_ml_kem_vector_barrett_reduce_element(v.elements[5U] + v.elements[7U]);
  v.elements[5U] = uu____6;
  int16_t uu____7 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b2, zeta1);
  v.elements[7U] = uu____7;
  int16_t a_minus_b3 = v.elements[(size_t)8U + (size_t)2U] - v.elements[(size_t)8U + (size_t)0U];
  int16_t
  uu____8 =
    libcrux_ml_kem_vector_barrett_reduce_element(v.elements[(size_t)8U
      + (size_t)0U]
      + v.elements[(size_t)8U + (size_t)2U]);
  v.elements[(size_t)8U + (size_t)0U] = uu____8;
  int16_t uu____9 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b3, zeta2);
  v.elements[(size_t)8U + (size_t)2U] = uu____9;
  int16_t a_minus_b4 = v.elements[(size_t)8U + (size_t)3U] - v.elements[(size_t)8U + (size_t)1U];
  int16_t
  uu____10 =
    libcrux_ml_kem_vector_barrett_reduce_element(v.elements[(size_t)8U
      + (size_t)1U]
      + v.elements[(size_t)8U + (size_t)3U]);
  v.elements[(size_t)8U + (size_t)1U] = uu____10;
  int16_t uu____11 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b4, zeta2);
  v.elements[(size_t)8U + (size_t)3U] = uu____11;
  int16_t a_minus_b5 = v.elements[(size_t)8U + (size_t)6U] - v.elements[(size_t)8U + (size_t)4U];
  int16_t
  uu____12 =
    libcrux_ml_kem_vector_barrett_reduce_element(v.elements[(size_t)8U
      + (size_t)4U]
      + v.elements[(size_t)8U + (size_t)6U]);
  v.elements[(size_t)8U + (size_t)4U] = uu____12;
  int16_t uu____13 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b5, zeta3);
  v.elements[(size_t)8U + (size_t)6U] = uu____13;
  int16_t a_minus_b6 = v.elements[(size_t)8U + (size_t)7U] - v.elements[(size_t)8U + (size_t)5U];
  int16_t
  uu____14 =
    libcrux_ml_kem_vector_barrett_reduce_element(v.elements[(size_t)8U
      + (size_t)5U]
      + v.elements[(size_t)8U + (size_t)7U]);
  v.elements[(size_t)8U + (size_t)5U] = uu____14;
  int16_t uu____15 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b6, zeta3);
  v.elements[(size_t)8U + (size_t)7U] = uu____15;
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_inv_ntt_layer_2_step(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t zeta0,
  int16_t zeta1
)
{
  int16_t a_minus_b = v.elements[4U] - v.elements[0U];
  v.elements[0U] = v.elements[0U] + v.elements[4U];
  int16_t uu____0 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b, zeta0);
  v.elements[4U] = uu____0;
  int16_t a_minus_b0 = v.elements[5U] - v.elements[1U];
  v.elements[1U] = v.elements[1U] + v.elements[5U];
  int16_t uu____1 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b0, zeta0);
  v.elements[5U] = uu____1;
  int16_t a_minus_b1 = v.elements[6U] - v.elements[2U];
  v.elements[2U] = v.elements[2U] + v.elements[6U];
  int16_t uu____2 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b1, zeta0);
  v.elements[6U] = uu____2;
  int16_t a_minus_b2 = v.elements[7U] - v.elements[3U];
  v.elements[3U] = v.elements[3U] + v.elements[7U];
  int16_t uu____3 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b2, zeta0);
  v.elements[7U] = uu____3;
  int16_t a_minus_b3 = v.elements[(size_t)8U + (size_t)4U] - v.elements[(size_t)8U + (size_t)0U];
  v.elements[(size_t)8U + (size_t)0U] =
    v.elements[(size_t)8U
    + (size_t)0U]
    + v.elements[(size_t)8U + (size_t)4U];
  int16_t uu____4 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b3, zeta1);
  v.elements[(size_t)8U + (size_t)4U] = uu____4;
  int16_t a_minus_b4 = v.elements[(size_t)8U + (size_t)5U] - v.elements[(size_t)8U + (size_t)1U];
  v.elements[(size_t)8U + (size_t)1U] =
    v.elements[(size_t)8U
    + (size_t)1U]
    + v.elements[(size_t)8U + (size_t)5U];
  int16_t uu____5 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b4, zeta1);
  v.elements[(size_t)8U + (size_t)5U] = uu____5;
  int16_t a_minus_b5 = v.elements[(size_t)8U + (size_t)6U] - v.elements[(size_t)8U + (size_t)2U];
  v.elements[(size_t)8U + (size_t)2U] =
    v.elements[(size_t)8U
    + (size_t)2U]
    + v.elements[(size_t)8U + (size_t)6U];
  int16_t uu____6 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b5, zeta1);
  v.elements[(size_t)8U + (size_t)6U] = uu____6;
  int16_t a_minus_b6 = v.elements[(size_t)8U + (size_t)7U] - v.elements[(size_t)8U + (size_t)3U];
  v.elements[(size_t)8U + (size_t)3U] =
    v.elements[(size_t)8U
    + (size_t)3U]
    + v.elements[(size_t)8U + (size_t)7U];
  int16_t uu____7 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b6, zeta1);
  v.elements[(size_t)8U + (size_t)7U] = uu____7;
  return v;
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_inv_ntt_layer_3_step(
  libcrux_ml_kem_vector_PortableVector v,
  int16_t zeta
)
{
  int16_t a_minus_b = v.elements[8U] - v.elements[0U];
  v.elements[0U] = v.elements[0U] + v.elements[8U];
  int16_t uu____0 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b, zeta);
  v.elements[8U] = uu____0;
  int16_t a_minus_b0 = v.elements[9U] - v.elements[1U];
  v.elements[1U] = v.elements[1U] + v.elements[9U];
  int16_t uu____1 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b0, zeta);
  v.elements[9U] = uu____1;
  int16_t a_minus_b1 = v.elements[10U] - v.elements[2U];
  v.elements[2U] = v.elements[2U] + v.elements[10U];
  int16_t uu____2 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b1, zeta);
  v.elements[10U] = uu____2;
  int16_t a_minus_b2 = v.elements[11U] - v.elements[3U];
  v.elements[3U] = v.elements[3U] + v.elements[11U];
  int16_t uu____3 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b2, zeta);
  v.elements[11U] = uu____3;
  int16_t a_minus_b3 = v.elements[12U] - v.elements[4U];
  v.elements[4U] = v.elements[4U] + v.elements[12U];
  int16_t uu____4 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b3, zeta);
  v.elements[12U] = uu____4;
  int16_t a_minus_b4 = v.elements[13U] - v.elements[5U];
  v.elements[5U] = v.elements[5U] + v.elements[13U];
  int16_t uu____5 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b4, zeta);
  v.elements[13U] = uu____5;
  int16_t a_minus_b5 = v.elements[14U] - v.elements[6U];
  v.elements[6U] = v.elements[6U] + v.elements[14U];
  int16_t uu____6 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b5, zeta);
  v.elements[14U] = uu____6;
  int16_t a_minus_b6 = v.elements[15U] - v.elements[7U];
  v.elements[7U] = v.elements[7U] + v.elements[15U];
  int16_t uu____7 = libcrux_ml_kem_vector_montgomery_multiply_fe_by_fer(a_minus_b6, zeta);
  v.elements[15U] = uu____7;
  return v;
}

inline K___int16_t_int16_t
libcrux_ml_kem_vector_ntt_multiply_binomials(
  K___int16_t_int16_t _,
  K___int16_t_int16_t _0,
  int16_t zeta
)
{
  int16_t a0 = _.fst;
  int16_t a1 = _.snd;
  int16_t b0 = _0.fst;
  int16_t b1 = _0.snd;
  int32_t uu____0 = (int32_t)a0 * (int32_t)b0;
  int16_t
  uu____1 =
    libcrux_ml_kem_vector_montgomery_reduce_element(uu____0
      +
        (int32_t)libcrux_ml_kem_vector_montgomery_reduce_element((int32_t)a1 * (int32_t)b1)
        * (int32_t)zeta);
  return
    (
      (K___int16_t_int16_t){
        .fst = uu____1,
        .snd = libcrux_ml_kem_vector_montgomery_reduce_element((int32_t)a0
          * (int32_t)b1
          + (int32_t)a1 * (int32_t)b0)
      }
    );
}

libcrux_ml_kem_vector_PortableVector
libcrux_ml_kem_vector_ntt_multiply(
  libcrux_ml_kem_vector_PortableVector *lhs,
  libcrux_ml_kem_vector_PortableVector *rhs,
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3
)
{
  libcrux_ml_kem_vector_PortableVector out = libcrux_ml_kem_vector_zero();
  K___int16_t_int16_t lit0;
  lit0.fst = lhs->elements[0U];
  lit0.snd = lhs->elements[1U];
  K___int16_t_int16_t lit1;
  lit1.fst = rhs->elements[0U];
  lit1.snd = rhs->elements[1U];
  K___int16_t_int16_t product = libcrux_ml_kem_vector_ntt_multiply_binomials(lit0, lit1, zeta0);
  out.elements[0U] = product.fst;
  out.elements[1U] = product.snd;
  K___int16_t_int16_t lit2;
  lit2.fst = lhs->elements[2U];
  lit2.snd = lhs->elements[3U];
  K___int16_t_int16_t lit3;
  lit3.fst = rhs->elements[2U];
  lit3.snd = rhs->elements[3U];
  K___int16_t_int16_t
  product0 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit2, lit3, -zeta0);
  out.elements[2U] = product0.fst;
  out.elements[3U] = product0.snd;
  K___int16_t_int16_t lit4;
  lit4.fst = lhs->elements[4U];
  lit4.snd = lhs->elements[5U];
  K___int16_t_int16_t lit5;
  lit5.fst = rhs->elements[4U];
  lit5.snd = rhs->elements[5U];
  K___int16_t_int16_t product1 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit4, lit5, zeta1);
  out.elements[4U] = product1.fst;
  out.elements[5U] = product1.snd;
  K___int16_t_int16_t lit6;
  lit6.fst = lhs->elements[6U];
  lit6.snd = lhs->elements[7U];
  K___int16_t_int16_t lit7;
  lit7.fst = rhs->elements[6U];
  lit7.snd = rhs->elements[7U];
  K___int16_t_int16_t
  product2 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit6, lit7, -zeta1);
  out.elements[6U] = product2.fst;
  out.elements[7U] = product2.snd;
  K___int16_t_int16_t lit8;
  lit8.fst = lhs->elements[(size_t)8U + (size_t)0U];
  lit8.snd = lhs->elements[(size_t)8U + (size_t)1U];
  K___int16_t_int16_t lit9;
  lit9.fst = rhs->elements[(size_t)8U + (size_t)0U];
  lit9.snd = rhs->elements[(size_t)8U + (size_t)1U];
  K___int16_t_int16_t product3 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit8, lit9, zeta2);
  out.elements[(size_t)8U + (size_t)0U] = product3.fst;
  out.elements[(size_t)8U + (size_t)1U] = product3.snd;
  K___int16_t_int16_t lit10;
  lit10.fst = lhs->elements[(size_t)8U + (size_t)2U];
  lit10.snd = lhs->elements[(size_t)8U + (size_t)3U];
  K___int16_t_int16_t lit11;
  lit11.fst = rhs->elements[(size_t)8U + (size_t)2U];
  lit11.snd = rhs->elements[(size_t)8U + (size_t)3U];
  K___int16_t_int16_t
  product4 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit10, lit11, -zeta2);
  out.elements[(size_t)8U + (size_t)2U] = product4.fst;
  out.elements[(size_t)8U + (size_t)3U] = product4.snd;
  K___int16_t_int16_t lit12;
  lit12.fst = lhs->elements[(size_t)8U + (size_t)4U];
  lit12.snd = lhs->elements[(size_t)8U + (size_t)5U];
  K___int16_t_int16_t lit13;
  lit13.fst = rhs->elements[(size_t)8U + (size_t)4U];
  lit13.snd = rhs->elements[(size_t)8U + (size_t)5U];
  K___int16_t_int16_t
  product5 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit12, lit13, zeta3);
  out.elements[(size_t)8U + (size_t)4U] = product5.fst;
  out.elements[(size_t)8U + (size_t)5U] = product5.snd;
  K___int16_t_int16_t lit14;
  lit14.fst = lhs->elements[(size_t)8U + (size_t)6U];
  lit14.snd = lhs->elements[(size_t)8U + (size_t)7U];
  K___int16_t_int16_t lit;
  lit.fst = rhs->elements[(size_t)8U + (size_t)6U];
  lit.snd = rhs->elements[(size_t)8U + (size_t)7U];
  K___int16_t_int16_t
  product6 = libcrux_ml_kem_vector_ntt_multiply_binomials(lit14, lit, -zeta3);
  out.elements[(size_t)8U + (size_t)6U] = product6.fst;
  out.elements[(size_t)8U + (size_t)7U] = product6.snd;
  return out;
}

void libcrux_ml_kem_vector_serialize_1(libcrux_ml_kem_vector_PortableVector v, uint8_t ret[2U])
{
  uint8_t result[2U] = { 0U };
  for (size_t i = (size_t)0U; i < (size_t)8U; i++)
  {
    size_t i0 = i;
    size_t uu____0 = (size_t)0U;
    result[uu____0] = (uint32_t)result[uu____0] | (uint32_t)(uint8_t)v.elements[i0] << (uint32_t)i0;
  }
  for (size_t i = (size_t)8U; i < (size_t)16U; i++)
  {
    size_t i0 = i;
    size_t uu____1 = (size_t)1U;
    result[uu____1] =
      (uint32_t)result[uu____1]
      | (uint32_t)(uint8_t)v.elements[i0] << (uint32_t)(i0 - (size_t)8U);
  }
  memcpy(ret, result, (size_t)2U * sizeof (uint8_t));
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_deserialize_1(Eurydice_slice v)
{
  libcrux_ml_kem_vector_PortableVector result = libcrux_ml_kem_vector_zero();
  for (size_t i = (size_t)0U; i < (size_t)8U; i++)
  {
    size_t i0 = i;
    uint8_t *uu____0 = &Eurydice_slice_index(v, (size_t)0U, uint8_t, uint8_t);
    result.elements[i0] = (int16_t)((uint32_t)uu____0[0U] >> (uint32_t)i0 & 1U);
  }
  for (size_t i = (size_t)8U; i < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_ELEMENTS_IN_VECTOR; i++)
  {
    size_t i0 = i;
    uint8_t *uu____1 = &Eurydice_slice_index(v, (size_t)1U, uint8_t, uint8_t);
    result.elements[i0] = (int16_t)((uint32_t)uu____1[0U] >> (uint32_t)(i0 - (size_t)8U) & 1U);
  }
  return result;
}

void libcrux_ml_kem_vector_serialize_4(libcrux_ml_kem_vector_PortableVector v, uint8_t ret[8U])
{
  uint8_t result[8U] = { 0U };
  result[0U] = (uint32_t)(uint8_t)v.elements[1U] << 4U | (uint32_t)(uint8_t)v.elements[0U];
  result[1U] = (uint32_t)(uint8_t)v.elements[3U] << 4U | (uint32_t)(uint8_t)v.elements[2U];
  result[2U] = (uint32_t)(uint8_t)v.elements[5U] << 4U | (uint32_t)(uint8_t)v.elements[4U];
  result[3U] = (uint32_t)(uint8_t)v.elements[7U] << 4U | (uint32_t)(uint8_t)v.elements[6U];
  result[4U] =
    (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)1U]
    << 4U
    | (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)0U];
  result[5U] =
    (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)3U]
    << 4U
    | (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)2U];
  result[6U] =
    (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)5U]
    << 4U
    | (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)4U];
  result[7U] =
    (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)7U]
    << 4U
    | (uint32_t)(uint8_t)v.elements[(size_t)8U + (size_t)6U];
  memcpy(ret, result, (size_t)8U * sizeof (uint8_t));
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_deserialize_4(Eurydice_slice bytes)
{
  libcrux_ml_kem_vector_PortableVector v = libcrux_ml_kem_vector_zero();
  uint8_t *uu____0 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v.elements[0U] = (int16_t)((uint32_t)uu____0[0U] & 15U);
  uint8_t *uu____1 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v.elements[1U] = (int16_t)((uint32_t)uu____1[0U] >> 4U & 15U);
  uint8_t *uu____2 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v.elements[2U] = (int16_t)((uint32_t)uu____2[0U] & 15U);
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v.elements[3U] = (int16_t)((uint32_t)uu____3[0U] >> 4U & 15U);
  uint8_t *uu____4 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  v.elements[4U] = (int16_t)((uint32_t)uu____4[0U] & 15U);
  uint8_t *uu____5 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  v.elements[5U] = (int16_t)((uint32_t)uu____5[0U] >> 4U & 15U);
  uint8_t *uu____6 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v.elements[6U] = (int16_t)((uint32_t)uu____6[0U] & 15U);
  uint8_t *uu____7 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v.elements[7U] = (int16_t)((uint32_t)uu____7[0U] >> 4U & 15U);
  uint8_t *uu____8 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  v.elements[8U] = (int16_t)((uint32_t)uu____8[0U] & 15U);
  uint8_t *uu____9 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  v.elements[9U] = (int16_t)((uint32_t)uu____9[0U] >> 4U & 15U);
  uint8_t *uu____10 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  v.elements[10U] = (int16_t)((uint32_t)uu____10[0U] & 15U);
  uint8_t *uu____11 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  v.elements[11U] = (int16_t)((uint32_t)uu____11[0U] >> 4U & 15U);
  uint8_t *uu____12 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  v.elements[12U] = (int16_t)((uint32_t)uu____12[0U] & 15U);
  uint8_t *uu____13 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  v.elements[13U] = (int16_t)((uint32_t)uu____13[0U] >> 4U & 15U);
  uint8_t *uu____14 = &Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  v.elements[14U] = (int16_t)((uint32_t)uu____14[0U] & 15U);
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  v.elements[15U] = (int16_t)((uint32_t)uu____15[0U] >> 4U & 15U);
  return v;
}

void
libcrux_ml_kem_vector_serialize_5(libcrux_ml_kem_vector_PortableVector v, uint8_t ret[10U])
{
  uint8_t result[10U] = { 0U };
  result[0U] = (uint8_t)((v.elements[1U] & (int16_t)7) << 5U | v.elements[0U]);
  result[1U] =
    (uint8_t)(((v.elements[3U] & (int16_t)1) << 7U | v.elements[2U] << 2U) | v.elements[1U] >> 3U);
  result[2U] = (uint8_t)((v.elements[4U] & (int16_t)15) << 4U | v.elements[3U] >> 1U);
  result[3U] =
    (uint8_t)(((v.elements[6U] & (int16_t)3) << 6U | v.elements[5U] << 1U) | v.elements[4U] >> 4U);
  result[4U] = (uint8_t)(v.elements[7U] << 3U | v.elements[6U] >> 2U);
  result[5U] =
    (uint8_t)((v.elements[(size_t)8U + (size_t)1U] & (int16_t)7)
    << 5U
    | v.elements[(size_t)8U + (size_t)0U]);
  result[6U] =
    (uint8_t)(((v.elements[(size_t)8U + (size_t)3U] & (int16_t)1)
    << 7U
    | v.elements[(size_t)8U + (size_t)2U] << 2U)
    | v.elements[(size_t)8U + (size_t)1U] >> 3U);
  result[7U] =
    (uint8_t)((v.elements[(size_t)8U + (size_t)4U] & (int16_t)15)
    << 4U
    | v.elements[(size_t)8U + (size_t)3U] >> 1U);
  result[8U] =
    (uint8_t)(((v.elements[(size_t)8U + (size_t)6U] & (int16_t)3)
    << 6U
    | v.elements[(size_t)8U + (size_t)5U] << 1U)
    | v.elements[(size_t)8U + (size_t)4U] >> 4U);
  result[9U] =
    (uint8_t)(v.elements[(size_t)8U
    + (size_t)7U]
    << 3U
    | v.elements[(size_t)8U + (size_t)6U] >> 2U);
  memcpy(ret, result, (size_t)10U * sizeof (uint8_t));
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_deserialize_5(Eurydice_slice bytes)
{
  libcrux_ml_kem_vector_PortableVector v = libcrux_ml_kem_vector_zero();
  uint8_t *uu____0 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v.elements[0U] = (int16_t)((uint32_t)uu____0[0U] & 31U);
  uint8_t
  uu____1 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t) & 3U) << 3U;
  uint8_t *uu____2 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v.elements[1U] = (int16_t)((uint32_t)uu____1 | (uint32_t)uu____2[0U] >> 5U);
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v.elements[2U] = (int16_t)((uint32_t)uu____3[0U] >> 2U & 31U);
  uint8_t
  uu____4 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t) & 15U) << 1U;
  uint8_t *uu____5 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v.elements[3U] = (int16_t)((uint32_t)uu____4 | (uint32_t)uu____5[0U] >> 7U);
  uint8_t
  uu____6 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t) & 1U) << 4U;
  uint8_t *uu____7 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  v.elements[4U] = (int16_t)((uint32_t)uu____6 | (uint32_t)uu____7[0U] >> 4U);
  uint8_t *uu____8 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v.elements[5U] = (int16_t)((uint32_t)uu____8[0U] >> 1U & 31U);
  uint8_t
  uu____9 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t) & 7U) << 2U;
  uint8_t *uu____10 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v.elements[6U] = (int16_t)((uint32_t)uu____9 | (uint32_t)uu____10[0U] >> 6U);
  uint8_t *uu____11 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  v.elements[7U] = (int16_t)((uint32_t)uu____11[0U] >> 3U);
  uint8_t *uu____12 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)0U, uint8_t, uint8_t);
  v.elements[8U] = (int16_t)((uint32_t)uu____12[0U] & 31U);
  uint8_t
  uu____13 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)1U, uint8_t, uint8_t) & 3U)
    << 3U;
  uint8_t *uu____14 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)0U, uint8_t, uint8_t);
  v.elements[9U] = (int16_t)((uint32_t)uu____13 | (uint32_t)uu____14[0U] >> 5U);
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)1U, uint8_t, uint8_t);
  v.elements[10U] = (int16_t)((uint32_t)uu____15[0U] >> 2U & 31U);
  uint8_t
  uu____16 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)2U, uint8_t, uint8_t) & 15U)
    << 1U;
  uint8_t *uu____17 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)1U, uint8_t, uint8_t);
  v.elements[11U] = (int16_t)((uint32_t)uu____16 | (uint32_t)uu____17[0U] >> 7U);
  uint8_t
  uu____18 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)3U, uint8_t, uint8_t) & 1U)
    << 4U;
  uint8_t *uu____19 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)2U, uint8_t, uint8_t);
  v.elements[12U] = (int16_t)((uint32_t)uu____18 | (uint32_t)uu____19[0U] >> 4U);
  uint8_t *uu____20 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)3U, uint8_t, uint8_t);
  v.elements[13U] = (int16_t)((uint32_t)uu____20[0U] >> 1U & 31U);
  uint8_t
  uu____21 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)4U, uint8_t, uint8_t) & 7U)
    << 2U;
  uint8_t *uu____22 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)3U, uint8_t, uint8_t);
  v.elements[14U] = (int16_t)((uint32_t)uu____21 | (uint32_t)uu____22[0U] >> 6U);
  uint8_t *uu____23 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)4U, uint8_t, uint8_t);
  v.elements[15U] = (int16_t)((uint32_t)uu____23[0U] >> 3U);
  return v;
}

void
libcrux_ml_kem_vector_serialize_10(libcrux_ml_kem_vector_PortableVector v, uint8_t ret[20U])
{
  uint8_t result[20U] = { 0U };
  result[0U] = (uint8_t)(v.elements[0U] & (int16_t)255);
  result[1U] =
    (uint32_t)(uint8_t)(v.elements[1U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v.elements[0U] >> 8U & (int16_t)3);
  result[2U] =
    (uint32_t)(uint8_t)(v.elements[2U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v.elements[1U] >> 6U & (int16_t)15);
  result[3U] =
    (uint32_t)(uint8_t)(v.elements[3U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v.elements[2U] >> 4U & (int16_t)63);
  result[4U] = (uint8_t)(v.elements[3U] >> 2U & (int16_t)255);
  result[5U] = (uint8_t)(v.elements[4U] & (int16_t)255);
  result[6U] =
    (uint32_t)(uint8_t)(v.elements[5U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v.elements[4U] >> 8U & (int16_t)3);
  result[7U] =
    (uint32_t)(uint8_t)(v.elements[6U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v.elements[5U] >> 6U & (int16_t)15);
  result[8U] =
    (uint32_t)(uint8_t)(v.elements[7U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v.elements[6U] >> 4U & (int16_t)63);
  result[9U] = (uint8_t)(v.elements[7U] >> 2U & (int16_t)255);
  result[10U] = (uint8_t)(v.elements[(size_t)8U + (size_t)0U] & (int16_t)255);
  result[11U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)1U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)0U] >> 8U & (int16_t)3);
  result[12U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)2U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)1U] >> 6U & (int16_t)15);
  result[13U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)3U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)2U] >> 4U & (int16_t)63);
  result[14U] = (uint8_t)(v.elements[(size_t)8U + (size_t)3U] >> 2U & (int16_t)255);
  result[15U] = (uint8_t)(v.elements[(size_t)8U + (size_t)4U] & (int16_t)255);
  result[16U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)5U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)4U] >> 8U & (int16_t)3);
  result[17U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)6U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)5U] >> 6U & (int16_t)15);
  result[18U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)7U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)6U] >> 4U & (int16_t)63);
  result[19U] = (uint8_t)(v.elements[(size_t)8U + (size_t)7U] >> 2U & (int16_t)255);
  memcpy(ret, result, (size_t)20U * sizeof (uint8_t));
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_deserialize_10(Eurydice_slice bytes)
{
  libcrux_ml_kem_vector_PortableVector result = libcrux_ml_kem_vector_zero();
  int16_t
  uu____0 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____1 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  result.elements[0U] = uu____0 | ((int16_t)uu____1[0U] & (int16_t)255);
  int16_t
  uu____2 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t) & (int16_t)15)
    << 6U;
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  result.elements[1U] = uu____2 | (int16_t)uu____3[0U] >> 2U;
  int16_t
  uu____4 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t) & (int16_t)63)
    << 4U;
  uint8_t *uu____5 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  result.elements[2U] = uu____4 | (int16_t)uu____5[0U] >> 4U;
  int16_t uu____6 = (int16_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____7 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  result.elements[3U] = uu____6 | (int16_t)uu____7[0U] >> 6U;
  int16_t
  uu____8 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____9 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  result.elements[4U] = uu____8 | ((int16_t)uu____9[0U] & (int16_t)255);
  int16_t
  uu____10 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t) & (int16_t)15)
    << 6U;
  uint8_t *uu____11 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  result.elements[5U] = uu____10 | (int16_t)uu____11[0U] >> 2U;
  int16_t
  uu____12 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t) & (int16_t)63)
    << 4U;
  uint8_t *uu____13 = &Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  result.elements[6U] = uu____12 | (int16_t)uu____13[0U] >> 4U;
  int16_t uu____14 = (int16_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
  result.elements[7U] = uu____14 | (int16_t)uu____15[0U] >> 6U;
  int16_t
  uu____16 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)1U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____17 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)0U, uint8_t, uint8_t);
  result.elements[8U] = uu____16 | ((int16_t)uu____17[0U] & (int16_t)255);
  int16_t
  uu____18 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)2U, uint8_t, uint8_t)
    & (int16_t)15)
    << 6U;
  uint8_t *uu____19 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)1U, uint8_t, uint8_t);
  result.elements[9U] = uu____18 | (int16_t)uu____19[0U] >> 2U;
  int16_t
  uu____20 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)3U, uint8_t, uint8_t)
    & (int16_t)63)
    << 4U;
  uint8_t *uu____21 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)2U, uint8_t, uint8_t);
  result.elements[10U] = uu____20 | (int16_t)uu____21[0U] >> 4U;
  int16_t
  uu____22 =
    (int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)4U, uint8_t, uint8_t)
    << 2U;
  uint8_t *uu____23 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)3U, uint8_t, uint8_t);
  result.elements[11U] = uu____22 | (int16_t)uu____23[0U] >> 6U;
  int16_t
  uu____24 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)6U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____25 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)5U, uint8_t, uint8_t);
  result.elements[12U] = uu____24 | ((int16_t)uu____25[0U] & (int16_t)255);
  int16_t
  uu____26 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)7U, uint8_t, uint8_t)
    & (int16_t)15)
    << 6U;
  uint8_t *uu____27 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)6U, uint8_t, uint8_t);
  result.elements[13U] = uu____26 | (int16_t)uu____27[0U] >> 2U;
  int16_t
  uu____28 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)8U, uint8_t, uint8_t)
    & (int16_t)63)
    << 4U;
  uint8_t *uu____29 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)7U, uint8_t, uint8_t);
  result.elements[14U] = uu____28 | (int16_t)uu____29[0U] >> 4U;
  int16_t
  uu____30 =
    (int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)9U, uint8_t, uint8_t)
    << 2U;
  uint8_t *uu____31 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)8U, uint8_t, uint8_t);
  result.elements[15U] = uu____30 | (int16_t)uu____31[0U] >> 6U;
  return result;
}

void
libcrux_ml_kem_vector_serialize_11(libcrux_ml_kem_vector_PortableVector v, uint8_t ret[22U])
{
  uint8_t result[22U] = { 0U };
  result[0U] = (uint8_t)v.elements[0U];
  result[1U] =
    (uint32_t)(uint8_t)(v.elements[1U] & (int16_t)31)
    << 3U
    | (uint32_t)(uint8_t)(v.elements[0U] >> 8U);
  result[2U] =
    (uint32_t)(uint8_t)(v.elements[2U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v.elements[1U] >> 5U);
  result[3U] = (uint8_t)(v.elements[2U] >> 2U & (int16_t)255);
  result[4U] =
    (uint32_t)(uint8_t)(v.elements[3U] & (int16_t)127)
    << 1U
    | (uint32_t)(uint8_t)(v.elements[2U] >> 10U);
  result[5U] =
    (uint32_t)(uint8_t)(v.elements[4U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v.elements[3U] >> 7U);
  result[6U] =
    (uint32_t)(uint8_t)(v.elements[5U] & (int16_t)1)
    << 7U
    | (uint32_t)(uint8_t)(v.elements[4U] >> 4U);
  result[7U] = (uint8_t)(v.elements[5U] >> 1U & (int16_t)255);
  result[8U] =
    (uint32_t)(uint8_t)(v.elements[6U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v.elements[5U] >> 9U);
  result[9U] =
    (uint32_t)(uint8_t)(v.elements[7U] & (int16_t)7)
    << 5U
    | (uint32_t)(uint8_t)(v.elements[6U] >> 6U);
  result[10U] = (uint8_t)(v.elements[7U] >> 3U);
  result[11U] = (uint8_t)v.elements[(size_t)8U + (size_t)0U];
  result[12U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)1U] & (int16_t)31)
    << 3U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)0U] >> 8U);
  result[13U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)2U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)1U] >> 5U);
  result[14U] = (uint8_t)(v.elements[(size_t)8U + (size_t)2U] >> 2U & (int16_t)255);
  result[15U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)3U] & (int16_t)127)
    << 1U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)2U] >> 10U);
  result[16U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)4U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)3U] >> 7U);
  result[17U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)5U] & (int16_t)1)
    << 7U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)4U] >> 4U);
  result[18U] = (uint8_t)(v.elements[(size_t)8U + (size_t)5U] >> 1U & (int16_t)255);
  result[19U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)6U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)5U] >> 9U);
  result[20U] =
    (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)7U] & (int16_t)7)
    << 5U
    | (uint32_t)(uint8_t)(v.elements[(size_t)8U + (size_t)6U] >> 6U);
  result[21U] = (uint8_t)(v.elements[(size_t)8U + (size_t)7U] >> 3U);
  memcpy(ret, result, (size_t)22U * sizeof (uint8_t));
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_deserialize_11(Eurydice_slice bytes)
{
  libcrux_ml_kem_vector_PortableVector result = libcrux_ml_kem_vector_zero();
  int16_t
  uu____0 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t) & (int16_t)7)
    << 8U;
  uint8_t *uu____1 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  result.elements[0U] = uu____0 | (int16_t)uu____1[0U];
  int16_t
  uu____2 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t) & (int16_t)63)
    << 5U;
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  result.elements[1U] = uu____2 | (int16_t)uu____3[0U] >> 3U;
  int16_t
  uu____4 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t) & (int16_t)1)
    << 10U;
  int16_t
  uu____5 = uu____4 | (int16_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____6 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  result.elements[2U] = uu____5 | (int16_t)uu____6[0U] >> 6U;
  int16_t
  uu____7 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t) & (int16_t)15)
    << 7U;
  uint8_t *uu____8 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  result.elements[3U] = uu____7 | (int16_t)uu____8[0U] >> 1U;
  int16_t
  uu____9 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t) & (int16_t)127)
    << 4U;
  uint8_t *uu____10 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  result.elements[4U] = uu____9 | (int16_t)uu____10[0U] >> 4U;
  int16_t
  uu____11 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t) & (int16_t)3)
    << 9U;
  int16_t
  uu____12 = uu____11 | (int16_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t) << 1U;
  uint8_t *uu____13 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  result.elements[5U] = uu____12 | (int16_t)uu____13[0U] >> 7U;
  int16_t
  uu____14 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t) & (int16_t)31)
    << 6U;
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
  result.elements[6U] = uu____14 | (int16_t)uu____15[0U] >> 2U;
  int16_t uu____16 = (int16_t)Eurydice_slice_index(bytes, (size_t)10U, uint8_t, uint8_t) << 3U;
  uint8_t *uu____17 = &Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t);
  result.elements[7U] = uu____16 | (int16_t)uu____17[0U] >> 5U;
  int16_t
  uu____18 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)1U, uint8_t, uint8_t) & (int16_t)7)
    << 8U;
  uint8_t *uu____19 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)0U, uint8_t, uint8_t);
  result.elements[8U] = uu____18 | (int16_t)uu____19[0U];
  int16_t
  uu____20 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)2U, uint8_t, uint8_t)
    & (int16_t)63)
    << 5U;
  uint8_t *uu____21 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)1U, uint8_t, uint8_t);
  result.elements[9U] = uu____20 | (int16_t)uu____21[0U] >> 3U;
  int16_t
  uu____22 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)4U, uint8_t, uint8_t) & (int16_t)1)
    << 10U;
  int16_t
  uu____23 =
    uu____22
    | (int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)3U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____24 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)2U, uint8_t, uint8_t);
  result.elements[10U] = uu____23 | (int16_t)uu____24[0U] >> 6U;
  int16_t
  uu____25 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)5U, uint8_t, uint8_t)
    & (int16_t)15)
    << 7U;
  uint8_t *uu____26 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)4U, uint8_t, uint8_t);
  result.elements[11U] = uu____25 | (int16_t)uu____26[0U] >> 1U;
  int16_t
  uu____27 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)6U, uint8_t, uint8_t)
    & (int16_t)127)
    << 4U;
  uint8_t *uu____28 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)5U, uint8_t, uint8_t);
  result.elements[12U] = uu____27 | (int16_t)uu____28[0U] >> 4U;
  int16_t
  uu____29 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)8U, uint8_t, uint8_t) & (int16_t)3)
    << 9U;
  int16_t
  uu____30 =
    uu____29
    | (int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)7U, uint8_t, uint8_t) << 1U;
  uint8_t *uu____31 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)6U, uint8_t, uint8_t);
  result.elements[13U] = uu____30 | (int16_t)uu____31[0U] >> 7U;
  int16_t
  uu____32 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)9U, uint8_t, uint8_t)
    & (int16_t)31)
    << 6U;
  uint8_t *uu____33 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)8U, uint8_t, uint8_t);
  result.elements[14U] = uu____32 | (int16_t)uu____33[0U] >> 2U;
  int16_t
  uu____34 =
    (int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)10U, uint8_t, uint8_t)
    << 3U;
  uint8_t *uu____35 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)9U, uint8_t, uint8_t);
  result.elements[15U] = uu____34 | (int16_t)uu____35[0U] >> 5U;
  return result;
}

void
libcrux_ml_kem_vector_serialize_12(libcrux_ml_kem_vector_PortableVector v, uint8_t ret[24U])
{
  uint8_t result[24U] = { 0U };
  result[0U] = (uint8_t)(v.elements[0U] & (int16_t)255);
  result[1U] = (uint8_t)(v.elements[0U] >> 8U | (v.elements[1U] & (int16_t)15) << 4U);
  result[2U] = (uint8_t)(v.elements[1U] >> 4U & (int16_t)255);
  result[3U] = (uint8_t)(v.elements[2U] & (int16_t)255);
  result[4U] = (uint8_t)(v.elements[2U] >> 8U | (v.elements[3U] & (int16_t)15) << 4U);
  result[5U] = (uint8_t)(v.elements[3U] >> 4U & (int16_t)255);
  result[6U] = (uint8_t)(v.elements[4U] & (int16_t)255);
  result[7U] = (uint8_t)(v.elements[4U] >> 8U | (v.elements[5U] & (int16_t)15) << 4U);
  result[8U] = (uint8_t)(v.elements[5U] >> 4U & (int16_t)255);
  result[9U] = (uint8_t)(v.elements[6U] & (int16_t)255);
  result[10U] = (uint8_t)(v.elements[6U] >> 8U | (v.elements[7U] & (int16_t)15) << 4U);
  result[11U] = (uint8_t)(v.elements[7U] >> 4U & (int16_t)255);
  result[12U] = (uint8_t)(v.elements[(size_t)8U + (size_t)0U] & (int16_t)255);
  result[13U] =
    (uint8_t)(v.elements[(size_t)8U
    + (size_t)0U]
    >> 8U
    | (v.elements[(size_t)8U + (size_t)1U] & (int16_t)15) << 4U);
  result[14U] = (uint8_t)(v.elements[(size_t)8U + (size_t)1U] >> 4U & (int16_t)255);
  result[15U] = (uint8_t)(v.elements[(size_t)8U + (size_t)2U] & (int16_t)255);
  result[16U] =
    (uint8_t)(v.elements[(size_t)8U
    + (size_t)2U]
    >> 8U
    | (v.elements[(size_t)8U + (size_t)3U] & (int16_t)15) << 4U);
  result[17U] = (uint8_t)(v.elements[(size_t)8U + (size_t)3U] >> 4U & (int16_t)255);
  result[18U] = (uint8_t)(v.elements[(size_t)8U + (size_t)4U] & (int16_t)255);
  result[19U] =
    (uint8_t)(v.elements[(size_t)8U
    + (size_t)4U]
    >> 8U
    | (v.elements[(size_t)8U + (size_t)5U] & (int16_t)15) << 4U);
  result[20U] = (uint8_t)(v.elements[(size_t)8U + (size_t)5U] >> 4U & (int16_t)255);
  result[21U] = (uint8_t)(v.elements[(size_t)8U + (size_t)6U] & (int16_t)255);
  result[22U] =
    (uint8_t)(v.elements[(size_t)8U
    + (size_t)6U]
    >> 8U
    | (v.elements[(size_t)8U + (size_t)7U] & (int16_t)15) << 4U);
  result[23U] = (uint8_t)(v.elements[(size_t)8U + (size_t)7U] >> 4U & (int16_t)255);
  memcpy(ret, result, (size_t)24U * sizeof (uint8_t));
}

libcrux_ml_kem_vector_PortableVector libcrux_ml_kem_vector_deserialize_12(Eurydice_slice bytes)
{
  libcrux_ml_kem_vector_PortableVector re = libcrux_ml_kem_vector_zero();
  int16_t byte0 = (int16_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  int16_t byte1 = (int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  int16_t byte2 = (int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  int16_t byte3 = (int16_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  int16_t byte4 = (int16_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  int16_t byte5 = (int16_t)Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  int16_t byte6 = (int16_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  int16_t byte7 = (int16_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  int16_t byte8 = (int16_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
  int16_t byte9 = (int16_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t);
  int16_t byte10 = (int16_t)Eurydice_slice_index(bytes, (size_t)10U, uint8_t, uint8_t);
  int16_t byte11 = (int16_t)Eurydice_slice_index(bytes, (size_t)11U, uint8_t, uint8_t);
  re.elements[0U] = (byte1 & (int16_t)15) << 8U | (byte0 & (int16_t)255);
  re.elements[1U] = byte2 << 4U | (byte1 >> 4U & (int16_t)15);
  re.elements[2U] = (byte4 & (int16_t)15) << 8U | (byte3 & (int16_t)255);
  re.elements[3U] = byte5 << 4U | (byte4 >> 4U & (int16_t)15);
  re.elements[4U] = (byte7 & (int16_t)15) << 8U | (byte6 & (int16_t)255);
  re.elements[5U] = byte8 << 4U | (byte7 >> 4U & (int16_t)15);
  re.elements[6U] = (byte10 & (int16_t)15) << 8U | (byte9 & (int16_t)255);
  re.elements[7U] = byte11 << 4U | (byte10 >> 4U & (int16_t)15);
  int16_t byte12 = (int16_t)Eurydice_slice_index(bytes, (size_t)12U, uint8_t, uint8_t);
  int16_t byte13 = (int16_t)Eurydice_slice_index(bytes, (size_t)13U, uint8_t, uint8_t);
  int16_t byte14 = (int16_t)Eurydice_slice_index(bytes, (size_t)14U, uint8_t, uint8_t);
  int16_t byte15 = (int16_t)Eurydice_slice_index(bytes, (size_t)15U, uint8_t, uint8_t);
  int16_t byte16 = (int16_t)Eurydice_slice_index(bytes, (size_t)16U, uint8_t, uint8_t);
  int16_t byte17 = (int16_t)Eurydice_slice_index(bytes, (size_t)17U, uint8_t, uint8_t);
  int16_t byte18 = (int16_t)Eurydice_slice_index(bytes, (size_t)18U, uint8_t, uint8_t);
  int16_t byte19 = (int16_t)Eurydice_slice_index(bytes, (size_t)19U, uint8_t, uint8_t);
  int16_t byte20 = (int16_t)Eurydice_slice_index(bytes, (size_t)20U, uint8_t, uint8_t);
  int16_t byte21 = (int16_t)Eurydice_slice_index(bytes, (size_t)21U, uint8_t, uint8_t);
  int16_t byte22 = (int16_t)Eurydice_slice_index(bytes, (size_t)22U, uint8_t, uint8_t);
  int16_t byte23 = (int16_t)Eurydice_slice_index(bytes, (size_t)23U, uint8_t, uint8_t);
  re.elements[8U] = (byte13 & (int16_t)15) << 8U | (byte12 & (int16_t)255);
  re.elements[9U] = byte14 << 4U | (byte13 >> 4U & (int16_t)15);
  re.elements[10U] = (byte16 & (int16_t)15) << 8U | (byte15 & (int16_t)255);
  re.elements[11U] = byte17 << 4U | (byte16 >> 4U & (int16_t)15);
  re.elements[12U] = (byte19 & (int16_t)15) << 8U | (byte18 & (int16_t)255);
  re.elements[13U] = byte20 << 4U | (byte19 >> 4U & (int16_t)15);
  re.elements[14U] = (byte22 & (int16_t)15) << 8U | (byte21 & (int16_t)255);
  re.elements[15U] = byte23 << 4U | (byte22 >> 4U & (int16_t)15);
  return re;
}

size_t libcrux_ml_kem_vector_rej_sample(Eurydice_slice a, Eurydice_slice result)
{
  size_t sampled = (size_t)0U;
  core_slice_iter_Chunks
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(core_slice___Slice_T___chunks(a,
        (size_t)3U,
        uint8_t,
        core_slice_iter_Chunks),
      core_slice_iter_Chunks,
      core_slice_iter_Chunks);
  while (true)
  {
    core_option_Option__Eurydice_slice_uint8_t
    uu____0 =
      core_slice_iter___core__iter__traits__iterator__Iterator_for_core__slice__iter__Chunks__a__T___70__next(&iter,
        uint8_t,
        core_option_Option__Eurydice_slice_uint8_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      Eurydice_slice bytes = uu____0.f0;
      int16_t b1 = (int16_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
      int16_t b2 = (int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
      int16_t b3 = (int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
      int16_t d1 = (b2 & (int16_t)15) << 8U | b1;
      int16_t d2 = b3 << 4U | b2 >> 4U;
      bool uu____1;
      if (d1 < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_MODULUS)
      {
        uu____1 = sampled < (size_t)16U;
      }
      else
      {
        uu____1 = false;
      }
      if (uu____1)
      {
        int16_t uu____2 = d1;
        Eurydice_slice_index(result, sampled, int16_t, int16_t) = uu____2;
        sampled++;
      }
      bool uu____3;
      if (d2 < LIBCRUX_ML_KEM_VECTOR_TRAITS_FIELD_MODULUS)
      {
        uu____3 = sampled < (size_t)16U;
      }
      else
      {
        uu____3 = false;
      }
      if (uu____3)
      {
        int16_t uu____4 = d2;
        Eurydice_slice_index(result, sampled, int16_t, int16_t) = uu____4;
        sampled++;
      }
    }
  }
  return sampled;
}

