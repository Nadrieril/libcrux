/*
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/jonathan/Code/eurydice/eurydice --config ../c.yaml
  ../../libcrux_ml_kem.llbc ../../libcrux_sha3.llbc F* version: b5cb71b8 KaRaMeL
  version: 40e3a603
 */

#ifndef __libcrux_mlkem_neon_H
#define __libcrux_mlkem_neon_H

#if defined(__cplusplus)
extern "C" {
#endif

#include "eurydice_glue.h"
#include "libcrux_core.h"
#include "libcrux_mlkem_portable.h"
#include "libcrux_sha3_neon.h"

typedef struct libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector_s {
  core_core_arch_arm_shared_neon_int16x8_t low;
  core_core_arch_arm_shared_neon_int16x8_t high;
} libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector;

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_ZERO(void);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___ZERO(
    void);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_from_i16_array(Eurydice_slice array);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___from_i16_array(
    Eurydice_slice array);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_add(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector lhs,
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *rhs);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___add(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector lhs,
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *rhs);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_sub(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector lhs,
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *rhs);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___sub(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector lhs,
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *rhs);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_multiply_by_constant(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___multiply_by_constant(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_bitwise_and_with_constant(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___bitwise_and_with_constant(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_cond_subtract_3329(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___cond_subtract_3329(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v);

#define LIBCRUX_ML_KEM_VECTOR_NEON_SIMD128OPS_BARRETT_MULTIPLIER \
  ((int16_t)20159)

core_core_arch_arm_shared_neon_int16x8_t
libcrux_ml_kem_vector_neon_simd128ops_barrett_reduce_int16x8_t(
    core_core_arch_arm_shared_neon_int16x8_t v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_barrett_reduce(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___barrett_reduce(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v);

core_core_arch_arm_shared_neon_int16x8_t
libcrux_ml_kem_vector_neon_simd128ops_montgomery_reduce_int16x8_t(
    core_core_arch_arm_shared_neon_int16x8_t low,
    core_core_arch_arm_shared_neon_int16x8_t high);

core_core_arch_arm_shared_neon_int16x8_t
libcrux_ml_kem_vector_neon_simd128ops_montgomery_multiply_by_constant_int16x8_t(
    core_core_arch_arm_shared_neon_int16x8_t v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_montgomery_multiply_by_constant(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___montgomery_multiply_by_constant(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_compress_1(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___compress_1(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v);

int16_t libcrux_ml_kem_vector_neon_simd128ops_mask_n_least_significant_bits(
    int16_t coefficient_bits);

core_core_arch_arm_shared_neon_int16x8_t
libcrux_ml_kem_vector_neon_simd128ops_montgomery_multiply_int16x8_t(
    core_core_arch_arm_shared_neon_int16x8_t v,
    core_core_arch_arm_shared_neon_int16x8_t c);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_ntt_layer_1_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t zeta1,
    int16_t zeta2, int16_t zeta3, int16_t zeta4);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___ntt_layer_1_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, int16_t zeta1,
    int16_t zeta2, int16_t zeta3, int16_t zeta4);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_ntt_layer_2_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t zeta1,
    int16_t zeta2);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___ntt_layer_2_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, int16_t zeta1,
    int16_t zeta2);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_ntt_layer_3_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t zeta);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___ntt_layer_3_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, int16_t zeta);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_inv_ntt_layer_1_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t zeta1,
    int16_t zeta2, int16_t zeta3, int16_t zeta4);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___inv_ntt_layer_1_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, int16_t zeta1,
    int16_t zeta2, int16_t zeta3, int16_t zeta4);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_inv_ntt_layer_2_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t zeta1,
    int16_t zeta2);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___inv_ntt_layer_2_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, int16_t zeta1,
    int16_t zeta2);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_inv_ntt_layer_3_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t zeta);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___inv_ntt_layer_3_step(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, int16_t zeta);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_ntt_multiply(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *lhs,
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *rhs, int16_t zeta1,
    int16_t zeta2, int16_t zeta3, int16_t zeta4);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___ntt_multiply(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *lhs,
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *rhs, int16_t zeta1,
    int16_t zeta2, int16_t zeta3, int16_t zeta4);

void libcrux_ml_kem_vector_neon_simd128ops_serialize_1(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, uint8_t ret[2U]);

void libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___serialize_1(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, uint8_t ret[2U]);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_deserialize_1(Eurydice_slice a);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___deserialize_1(
    Eurydice_slice a);

void libcrux_ml_kem_vector_neon_simd128ops_serialize_4(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, uint8_t ret[8U]);

void libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___serialize_4(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, uint8_t ret[8U]);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_deserialize_4(Eurydice_slice v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___deserialize_4(
    Eurydice_slice a);

void libcrux_ml_kem_vector_neon_simd128ops_to_i16_array(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, int16_t ret[16U]);

void libcrux_ml_kem_vector_neon_simd128ops_serialize_5(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, uint8_t ret[10U]);

void libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___serialize_5(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, uint8_t ret[10U]);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_deserialize_5(Eurydice_slice v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___deserialize_5(
    Eurydice_slice a);

void libcrux_ml_kem_vector_neon_simd128ops_serialize_10(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, uint8_t ret[20U]);

void libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___serialize_10(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, uint8_t ret[20U]);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_deserialize_10(Eurydice_slice v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___deserialize_10(
    Eurydice_slice a);

void libcrux_ml_kem_vector_neon_simd128ops_serialize_11(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, uint8_t ret[22U]);

void libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___serialize_11(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, uint8_t ret[22U]);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_deserialize_11(Eurydice_slice v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___deserialize_11(
    Eurydice_slice a);

void libcrux_ml_kem_vector_neon_simd128ops_serialize_12(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector v, uint8_t ret[24U]);

void libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___serialize_12(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector a, uint8_t ret[24U]);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops_deserialize_12(Eurydice_slice v);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___deserialize_12(
    Eurydice_slice a);

size_t libcrux_ml_kem_vector_neon_rej_sample(Eurydice_slice a,
                                             Eurydice_slice result);

size_t
libcrux_ml_kem_vector_neon___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___rej_sample(
    Eurydice_slice a, Eurydice_slice out);

libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector
libcrux_ml_kem_vector_neon_simd128ops___core__clone__Clone_for_libcrux_ml_kem__vector__neon__simd128ops__SIMD128Vector___clone(
    libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector *self);

typedef struct
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector_s {
  libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector coefficients[16U];
} libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_neon_simd128ops_SIMD128Vector;

#if defined(__cplusplus)
}
#endif

#define __libcrux_mlkem_neon_H_DEFINED
#endif
